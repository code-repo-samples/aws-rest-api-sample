name: Artillery Fargate Test Runner

on:
  workflow_dispatch:
    inputs:
      app-folder:
        description: 'Target application folder'
        required: true
        default: 'app1'
      script-file:
        description: 'Artillery script to run (relative to app folder)'
        required: true
        default: 'scripts/load-test.yml'
      cpu:
        description: 'CPU units per Fargate task'
        required: false
        default: '4096'
      memory:
        description: 'Memory (MB) per Fargate task'
        required: false
        default: '8192'
      engines:
        description: 'Number of parallel Fargate engines/tasks'
        required: false
        default: '1'

jobs:
  run-artillery:
    runs-on: ubuntu-latest

    env:
      # Local folder for reports/artifacts
      ARTIFACTS_DIR: reports
      AWS_REGION: us-east-1
      ARTILLERY_OUTPUT_JSON: artillery_output.json
      ARTILLERY_HTML_REPORT_DIR: htmlreport

    steps:

      # 1Ô∏è‚É£ Checkout repo
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ Setup Node.js
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      # 3Ô∏è‚É£ Install dependencies safely
      - name: Install dependencies
        run: |
          
          npm install -g artillery@2.0.21

      # 4Ô∏è‚É£ Verify app folder and script exist
      - name: Verify app folder and script
        run: |
          APP_FOLDER="${{ github.event.inputs.app-folder }}"
          SCRIPT_FILE="${{ github.event.inputs.script-file }}"

          if [ ! -d "$APP_FOLDER" ]; then
            echo "‚ùå App folder does not exist: $APP_FOLDER"
            exit 1
          fi

          if [ ! -f "$APP_FOLDER/$SCRIPT_FILE" ]; then
            echo "‚ùå Artillery script does not exist: $APP_FOLDER/$SCRIPT_FILE"
            exit 1
          fi

          echo "‚úÖ App folder and script verified."

      # 5Ô∏è‚É£ Assume Artillery Fargate Role (STS)
      - name: Generate temporary AWS credentials for Fargate
        id: sts
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.ARTILLERY_AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.ARTILLERY_AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          echo "Assuming role ${{ secrets.ARTILLERY_AWS_ROLE_ARN }}..."
          CREDS=$(aws sts assume-role \
            --role-arn "${{ secrets.ARTILLERY_AWS_ROLE_ARN }}" \
            --role-session-name github-artillery-session \
            --duration-seconds 3600 \
            --output json)

          export AWS_ACCESS_KEY_ID=$(echo $CREDS | jq -r '.Credentials.AccessKeyId')
          export AWS_SECRET_ACCESS_KEY=$(echo $CREDS | jq -r '.Credentials.SecretAccessKey')
          export AWS_SESSION_TOKEN=$(echo $CREDS | jq -r '.Credentials.SessionToken')

          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN" >> $GITHUB_ENV

      # 6Ô∏è‚É£ Create local reports folder
      - name: Create reports folder
        run: mkdir -p ${{ env.ARTIFACTS_DIR }}

      # 7Ô∏è‚É£ Run Artillery Fargate
      - name: Run Artillery Fargate
        env:
          APP_AWS_KEY: ${{ secrets.APP1_AWS_ACCESS_KEY }}
          APP_AWS_SECRET: ${{ secrets.APP1_AWS_SECRET_KEY }}
          APP_AWS_SESSION: ${{ secrets.APP1_AWS_SESSION_TOKEN }}
          APP_URL: ${{ secrets.APP1_URL }}
          APP_AUTH_TOKEN: ${{ secrets.APP1_AUTH_TOKEN }}
        run: |
          APP_FOLDER="${{ github.event.inputs.app-folder }}"
          SCRIPT_FILE="${{ github.event.inputs.script-file }}"
          REPORTS_DIR="${{ env.ARTIFACTS_DIR }}"
          OUTPUT_JSON="$REPORTS_DIR/${{ env.ARTILLERY_OUTPUT_JSON }}"

          artillery run-fargate "$APP_FOLDER/$SCRIPT_FILE" \
            --cpu "${{ github.event.inputs.cpu }}" \
            --memory "${{ github.event.inputs.memory }}" \
            --engines "${{ github.event.inputs.engines }}" \
            --output "$OUTPUT_JSON"

      # 8Ô∏è‚É£ Generate HTML report (with .html)
      - name: Generate HTML report
        run: |
          REPORTS_DIR="${{ env.ARTIFACTS_DIR }}"
          OUTPUT_JSON="$REPORTS_DIR/${{ env.ARTILLERY_OUTPUT_JSON }}"
          HTML_FILE="$REPORTS_DIR/${{ env.ARTILLERY_HTML_REPORT_DIR }}/report.html"
          mkdir -p "$(dirname "$HTML_FILE")"

          artillery report "$OUTPUT_JSON" --output "$HTML_FILE"

      # 9Ô∏è‚É£ Download all S3 artifacts under this runId
      - name: Download S3 artifacts
        env:
          BUCKET_NAME: ${{ secrets.ARTILLERY_METRICS_BUCKET }}
        run: |
          REPORTS_DIR="${{ env.ARTIFACTS_DIR }}"
          OUTPUT_JSON="$REPORTS_DIR/${{ env.ARTILLERY_OUTPUT_JSON }}"
          ARTILLERY_RUN_ID=$(jq -r '.runId // empty' "$OUTPUT_JSON")

          if [ -n "$ARTILLERY_RUN_ID" ]; then
            echo "Downloading all artifacts from s3://$BUCKET_NAME/test-runs/$ARTILLERY_RUN_ID/"
            mkdir -p "$REPORTS_DIR/$ARTILLERY_RUN_ID"

            # Recursive copy ensures logs, jsonl, txt, and any other files
            aws s3 cp "s3://$BUCKET_NAME/test-runs/$ARTILLERY_RUN_ID/" \
              "$REPORTS_DIR/$ARTILLERY_RUN_ID/" --recursive --quiet
          else
            echo "Run ID not found; skipping S3 download."
          fi

      # üîü Upload all reports as GitHub artifact (v4)
      - name: Upload reports
        uses: actions/upload-artifact@v4
        with:
          name: artillery-reports-${{ github.event.inputs.app-folder }}
          path: ${{ env.ARTIFACTS_DIR }}/
